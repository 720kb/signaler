{"version":3,"file":"signaler-min.js","sources":["../../lib/frontend/p2p.js","../../lib/frontend/signaler.js"],"sourcesContent":["/*global RTCPeerConnection,RTCSessionDescription,RTCIceCandidate*/\nimport Rx from 'rxjs/Rx';\n\nconst rtcConfiguration = {\n    'iceServers': [\n      {\n        'urls': 'stun:stun.l.google.com:19302'\n      },\n      {\n        'urls': 'stun:23.21.150.121'\n      }\n    ]\n  }\n  , rtcOptions = {}\n  , rtcDataChannelOptions = {}\n  , iceCandidatesSym = Symbol('ice-candidates')\n  , peerConnectionSym = Symbol('peer-connection')\n  , dataChannelSym = Symbol('data-channel');\n\nclass SignalerPeerConnection extends Rx.Observable {\n\n  constructor(sdpConstr) {\n\n    if (!sdpConstr) {\n\n      throw new Error('Manadatory spd constraints missing.');\n    }\n\n    const internalObservable = new Rx.Observable(subscriber => {\n      const dataChannelError = error => {\n\n        subscriber.error({\n          'type': 'error',\n          'cause': error\n        });\n      }\n      , dataChannelMessage = event => {\n\n        if (event &&\n          event.data) {\n\n          if ((typeof event.data === 'string' || String.prototype.isPrototypeOf(event.data)) &&\n            event.data.indexOf('_signaler') >= 0) {\n\n            switch (event.data) {\n              case '_signaler:got-stream?': {\n\n                subscriber.next({\n                  'type': 'add-stream'\n                });\n                break;\n              }\n              default: {\n\n                subscriber.error({\n                  'type': 'warn',\n                  'cause': 'Not interesting event atm'\n                });\n              }\n            }\n          } else {\n\n            subscriber.next({\n              'type': 'datachannel-message',\n              'payload': JSON.parse(event.data)\n            });\n          }\n        } else {\n\n          subscriber.error({\n            'type': 'error',\n            'cause': 'Event data not present'\n          });\n        }\n      }\n      , dataChannelOpen = () => {\n\n        subscriber.next({\n          'type': 'datachannel-opened'\n        });\n      }\n      , dataChannelClose = () => {\n\n        subscriber.next({\n          'type': 'datachannel-closed'\n        });\n      };\n\n      this[peerConnectionSym] = new RTCPeerConnection(rtcConfiguration, rtcOptions);\n      this[dataChannelSym] = this[peerConnectionSym].createDataChannel('signaler-datachannel', rtcDataChannelOptions);\n\n      this[dataChannelSym].onerror = dataChannelError;\n      this[dataChannelSym].onmessage = dataChannelMessage;\n      this[dataChannelSym].onopen = dataChannelOpen;\n      this[dataChannelSym].onclose = dataChannelClose;\n\n      this[peerConnectionSym].onicecandidate = event => {\n\n        if (event.candidate) {\n\n          this[iceCandidatesSym].push(event.candidate);\n        } else if (this[iceCandidatesSym] &&\n          this[iceCandidatesSym].length >= 0) {\n\n          subscriber.next({\n            'type': 'use-ice-candidates',\n            'candidates': this[iceCandidatesSym].splice(0, this[iceCandidatesSym].length)\n          });\n        }\n      };\n\n      this[peerConnectionSym].onaddstream = event => {\n\n        if (!event ||\n          !event.stream) {\n\n          return subscriber.error({\n            'type': 'warning',\n            'cause': 'No stream arrived'\n          });\n        }\n\n        subscriber.next({\n          'type': 'add-stream',\n          'stream': event.stream\n        });\n      };\n\n      this[peerConnectionSym].onremovestream = event => {\n\n        if (!event ||\n          !event.stream) {\n\n          return subscriber.error({\n            'type': 'warning',\n            'cause': 'No stream arrived'\n          });\n        }\n\n        subscriber.next({\n          'type': 'remove-stream',\n          'stream': event.stream\n        });\n      };\n\n      this[peerConnectionSym].onnegotiationneeded = () => {\n\n        this[peerConnectionSym].createOffer()\n          .then(offer => {\n\n            subscriber.next({\n              'type': 'offer',\n              offer\n            });\n            return this[peerConnectionSym].setLocalDescription(new RTCSessionDescription(offer));\n          })\n          .catch(error => {\n\n            subscriber.error({\n              'type': 'error',\n              'cause': error\n            });\n          });\n      };\n\n      this[peerConnectionSym].oniceconnectionstatechange = event => {\n\n        if (!event ||\n          !event.target ||\n          !event.target.iceConnectionState) {\n\n          return subscriber.error({\n            'type': 'warning',\n            'cause': 'ice connection state changed without event value'\n          });\n        }\n\n        switch (event.target.iceConnectionState) {\n\n          case 'connected':\n          case 'completed': {\n\n            subscriber.next({\n              'type': 'ready'\n            });\n            break;\n          }\n\n          default: {\n\n            subscriber.next({\n              'type': 'ice-connection-state',\n              'state': event.target.iceConnectionState\n            });\n          }\n        }\n      };\n\n      this[peerConnectionSym].onsignalingstatechange = event => {\n\n        if (!event ||\n          !event.target ||\n          !event.target.signalingState) {\n\n          return subscriber.error({\n            'type': 'error',\n            'cause': 'signaling state changed without event value'\n          });\n        }\n\n        switch (event.target.signalingState) {\n\n          default: {\n\n            subscriber.next({\n              'type': 'signaling-state',\n              'state': event.target.signalingState\n            });\n          }\n        }\n      };\n\n      this[peerConnectionSym].ondatachannel = event => {\n\n        if (!event ||\n          !event.channel) {\n\n          return subscriber.error({\n            'type': 'error',\n            'cause': 'channel in event is not present'\n          });\n        }\n\n        event.channel.onerror = dataChannelError;\n        event.channel.onmessage = dataChannelMessage;\n        event.channel.onopen = dataChannelOpen;\n        event.channel.onclose = dataChannelClose;\n      };\n\n      this.setRemoteDescription = payload => {\n\n        if (!this[peerConnectionSym].remoteDescription.type) {\n\n          const setRemoteDescriptionPromise = this[peerConnectionSym].setRemoteDescription(new RTCSessionDescription(payload));\n\n          if (!this[peerConnectionSym].localDescription.type) {\n\n            setRemoteDescriptionPromise\n              .then(() => {\n\n                return this[peerConnectionSym].createAnswer(this.sdpConstr);\n              })\n              .then(answer => {\n\n                subscriber.next({\n                  'type': 'answer',\n                  answer\n                });\n                return this[peerConnectionSym].setLocalDescription(new RTCSessionDescription(answer));\n              })\n              .catch(error => {\n\n                subscriber.error({\n                  'type': 'error',\n                  'cause': error\n                });\n              });\n          }\n        }\n      };\n\n      return () => {\n\n        this[dataChannelSym].close();\n        this[peerConnectionSym].close();\n      };\n    }).share();\n\n    super(observer => {\n\n      const subscriptionToInternalObservable = internalObservable\n        .subscribe(observer);\n\n      return () => {\n\n        subscriptionToInternalObservable.unsubscribe();\n      };\n    });\n\n    internalObservable.forEach(element => console.info(element));\n\n    this[iceCandidatesSym] = [];\n    this.sdpConstr = sdpConstr;\n  }\n\n  addIceCandidates(candidates) {\n\n    if (candidates) {\n\n      candidates.forEach(element => this[peerConnectionSym].addIceCandidate(new RTCIceCandidate(element)));\n    } else {\n\n      throw new Error('Invalid candidates');\n    }\n  }\n\n  get dataChannel() {\n\n    if (!this[dataChannelSym]) {\n\n      throw new Error('Datachannel is not created');\n    }\n\n    return this[dataChannelSym];\n  }\n}\n\nexport {SignalerPeerConnection};\n","/*global window,navigator*/\nimport Rx from 'rxjs/Rx';\nimport {Comunicator} from 'comunicator';\nimport {SignalerPeerConnection} from './p2p.js';\n\nconst comunicatorSym = Symbol('comunicator')\n  , myStreamSym = Symbol('my-stream')\n  , userMediaConstraintsSym = Symbol('user-media-constraint')\n  , sdpConstraintsSym = Symbol('sdp-constraints')\n  , initiatorsSym = Symbol('initiators')\n  , peersSym = Symbol('peers')\n  , unknownPeerValue = 'unknown-peer'\n  , getUserMediaConstraints = {\n    'audio': true,\n    'video': true\n  }\n  , sdpConstraints = {\n    'mandatory': {\n      'OfferToReceiveAudio': true,\n      'OfferToReceiveVideo': true\n    }\n  };\n\nclass Signaler extends Rx.Observable {\n  constructor(websocketUrl, getUserMediaConstr = getUserMediaConstraints, sdpConstr = sdpConstraints) {\n\n    const internalObservable = new Rx.Observable(subscriber => {\n\n      this[comunicatorSym]\n        .filter(element => element.what &&\n          element.what.type === 'do-handshake')\n        .forEach(element => {\n\n          if (element.whoami &&\n            element.what.channel) {\n            const p2pConnection = new SignalerPeerConnection(sdpConstr);\n\n            this[initiatorsSym].set(element.what.channel, element.who);\n\n            p2pConnection\n              .filter(fromPeerConnection => fromPeerConnection.type === 'offer')\n              .forEach(fromPeerConnection => this[comunicatorSym].sendTo(element.whoami, {\n                'channel': element.what.channel,\n                'offer': fromPeerConnection.offer\n              }));\n\n            p2pConnection\n              .filter(fromPeerConnection => fromPeerConnection.type === 'use-ice-candidates')\n              .forEach(fromPeerConnection => this[comunicatorSym].sendTo(element.whoami, {\n                'channel': element.what.channel,\n                'candidates': fromPeerConnection.candidates\n              }));\n\n            p2pConnection\n              .filter(fromPeerConnection => fromPeerConnection.type === 'datachannel-message')\n              .forEach(fromPeerConnection => subscriber.next(fromPeerConnection));\n            this[peersSym].set(`${element.what.channel}-${element.who}`, p2pConnection);\n          } else {\n\n            window.setTimeout(() => {\n\n              throw new Error('Missing sender and channel that are mandatory');\n            });\n          }\n        });\n\n      this[comunicatorSym]\n        .filter(element => element.what &&\n        element.what.offer)\n        .forEach(element => {\n\n          if (element.whoami &&\n            element.what.channel &&\n            element.what.offer) {\n            let p2pConnection;\n\n            if (this[peersSym].has(`${element.what.channel}-${element.who}`)) {\n\n              p2pConnection = this[peersSym].get(`${element.what.channel}-${element.who}`);\n            } else {\n              p2pConnection = new SignalerPeerConnection(sdpConstr);\n\n              this[initiatorsSym].set(element.what.channel, element.whoami);\n              this[peersSym].set(`${element.what.channel}-${element.who}`, p2pConnection);\n            }\n\n            p2pConnection\n              .filter(fromPeerConnection => fromPeerConnection.type === 'answer')\n              .forEach(fromPeerConnection => this[comunicatorSym].sendTo(element.whoami, {\n                'channel': element.what.channel,\n                'answer': fromPeerConnection.answer\n              }));\n\n            p2pConnection\n              .filter(fromPeerConnection => fromPeerConnection.type === 'use-ice-candidates')\n              .forEach(fromPeerConnection => this[comunicatorSym].sendTo(element.whoami, {\n                'channel': element.what.channel,\n                'candidates': fromPeerConnection.candidates\n              }));\n\n            p2pConnection\n              .filter(fromPeerConnection => fromPeerConnection.type === 'datachannel-message')\n              .forEach(fromPeerConnection => subscriber.next(fromPeerConnection));\n            p2pConnection.setRemoteDescription(element.what.offer);\n          } else {\n\n            window.setTimeout(() => {\n\n              throw new Error('Missing sender, channel and the offer that are mandatory');\n            });\n          }\n        });\n\n      this[comunicatorSym]\n        .filter(element => element.what &&\n        element.what.answer)\n        .forEach(element => {\n\n          if (element.whoami &&\n            element.what.channel &&\n            element.what.answer) {\n            let p2pConnection;\n\n            if (this[peersSym].has(`${element.what.channel}-${element.who}`)) {\n\n              p2pConnection = this[peersSym].get(`${element.what.channel}-${element.who}`);\n            } else {\n\n              window.setTimeout(() => {\n\n                throw new Error('The peer connection must be already enstablished');\n              });\n            }\n\n            p2pConnection.setRemoteDescription(element.what.answer);\n          } else {\n\n            window.setTimeout(() => {\n\n              throw new Error('Missing sender, channel and the answer that are mandatory');\n            });\n          }\n        });\n\n      this[comunicatorSym]\n        .filter(element => element.what &&\n        element.what.candidates)\n        .forEach(element => {\n          let p2pConnection;\n\n          if (this[peersSym].has(`${element.what.channel}-${element.who}`)) {\n\n            p2pConnection = this[peersSym].get(`${element.what.channel}-${element.who}`);\n          } else {\n\n            window.setTimeout(() => {\n\n              throw new Error('The peer connection must be already enstablished');\n            });\n          }\n\n          p2pConnection.addIceCandidates(element.what.candidates);\n        });\n\n      this.getUserMedia = () => {\n\n        navigator.mediaDevices.getUserMedia(this.userMediaConstraints)\n          .then(localStream => {\n\n            if (!this[myStreamSym]) {\n\n              subscriber.next({\n                'type': 'my-stream',\n                'stream': localStream\n              });\n              this[myStreamSym] = localStream;\n            }\n\n            //TODO try to put the contextified audio\n            //audioContext.createMediaStreamSource(myStream);\n            //, contextifiedLocalStream = audioContext.createMediaStreamDestination();\n          })\n          .catch(error => {\n\n            throw new Error(error);\n          });\n      };\n    }).share();\n\n    super(observer => {\n\n      const subscriptionToInternalObservable = internalObservable\n        .subscribe(observer);\n\n      return () => {\n\n        subscriptionToInternalObservable.unsubscribe();\n      };\n    });\n\n    setTimeout(() => {\n\n      internalObservable.forEach(element => console.info(element));\n    })\n\n    this[comunicatorSym] = new Comunicator(websocketUrl);\n    this[userMediaConstraintsSym] = getUserMediaConstr;\n    this[sdpConstraintsSym] = sdpConstr;\n    this[peersSym] = new Map();\n    this[initiatorsSym] = new Map();\n  }\n\n  createChannel(channel) {\n\n    if (!channel) {\n\n      throw new Error('Missing mandatory <channel> parameter.');\n    }\n\n    this[comunicatorSym].sendTo(unknownPeerValue, {\n      'type': 'create-channel',\n      channel\n    }, true);\n  }\n\n  joinChannel(channel) {\n\n    if (!channel) {\n\n      throw new Error('Missing mandatory <channel> parameter.');\n    }\n\n    this[comunicatorSym].sendTo(unknownPeerValue, {\n      'type': 'join-channel',\n      channel\n    }, true);\n  }\n\n  streamOnChannel() {\n\n  }\n\n  sendTo(channel, who, what) {\n\n    if (this[peersSym].has(`${channel}-${who}`)) {\n      const dataChannel = this[peersSym].get(`${channel}-${who}`).dataChannel;\n\n      dataChannel.send(JSON.stringify(what));\n    } else {\n\n      throw new Error(`User ${who} for channel ${channel} do not exist`);\n    }\n  }\n\n  broadcast(channel, what) {\n    const mapKeys = this[peersSym].keys();\n\n    for (const aMapKey of mapKeys) {\n      const channelAndWho = aMapKey.split('-');\n\n      if (channelAndWho[0] === String(channel)) {\n        const dataChannel = this[peersSym].get(aMapKey).dataChannel;\n\n        dataChannel.send(JSON.stringify(what));\n      }\n    }\n  }\n\n  approve() {\n\n  }\n\n  unApprove() {\n\n  }\n\n  leaveChannel() {\n\n  }\n\n  userIsPresent(whoami, token) {\n\n    return this[comunicatorSym].userIsPresent(whoami, token);\n  }\n\n  get userMediaConstraints() {\n\n    return this[userMediaConstraintsSym];\n  }\n\n  get sdpConstraints() {\n\n    return this[sdpConstraintsSym];\n  }\n\n  get stream() {\n\n    if (!this[myStreamSym]) {\n\n      throw new Error('Stream is not present. You have to ask this to the user');\n    }\n\n    return this[myStreamSym];\n  }\n\n  get peers() {\n\n    return this[peersSym];\n  }\n\n  get initiators() {\n\n    return this[initiatorsSym];\n  }\n}\n\nexport {Signaler};\n"],"names":["rtcConfiguration","rtcOptions","rtcDataChannelOptions","iceCandidatesSym","Symbol","peerConnectionSym","dataChannelSym","SignalerPeerConnection","sdpConstr","Error","internalObservable","Rx","Observable","dataChannelError","error","dataChannelMessage","event","data","String","prototype","isPrototypeOf","indexOf","next","JSON","parse","dataChannelOpen","dataChannelClose","RTCPeerConnection","_this","createDataChannel","onerror","onmessage","onopen","onclose","onicecandidate","candidate","push","length","splice","onaddstream","stream","subscriber","onremovestream","onnegotiationneeded","createOffer","then","setLocalDescription","RTCSessionDescription","offer","oniceconnectionstatechange","target","iceConnectionState","onsignalingstatechange","signalingState","ondatachannel","channel","setRemoteDescription","remoteDescription","type","setRemoteDescriptionPromise","payload","localDescription","createAnswer","answer","close","share","subscriptionToInternalObservable","subscribe","observer","unsubscribe","forEach","console","info","element","candidates","_this2","addIceCandidate","RTCIceCandidate","this","comunicatorSym","myStreamSym","userMediaConstraintsSym","sdpConstraintsSym","initiatorsSym","peersSym","unknownPeerValue","getUserMediaConstraints","sdpConstraints","Signaler","websocketUrl","getUserMediaConstr","filter","what","whoami","p2pConnection","set","who","fromPeerConnection","sendTo","setTimeout","has","get","addIceCandidates","getUserMedia","mediaDevices","userMediaConstraints","localStream","Comunicator","Map","dataChannel","send","stringify","mapKeys","keys","aMapKey","channelAndWho","split","token","userIsPresent"],"mappings":"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"}