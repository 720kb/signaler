{"version":3,"file":"signaler-min.js","sources":["../../lib/frontend/p2p.js","../../lib/frontend/signaler.js"],"sourcesContent":["/*global RTCPeerConnection,RTCSessionDescription,RTCIceCandidate*/\nimport Rx from 'rxjs/Rx';\n\nconst rtcConfiguration = {\n    'iceServers': [\n      {\n        'urls': 'stun:stun.l.google.com:19302'\n      },\n      {\n        'urls': 'stun:23.21.150.121'\n      }\n    ]\n  }\n  , rtcOptions = {}\n  , rtcDataChannelOptions = {}\n  , iceCandidatesSym = Symbol('ice-candidates')\n  , peerConnectionSym = Symbol('peer-connection')\n  , dataChannelSym = Symbol('data-channel');\n\nclass SignalerPeerConnection extends Rx.Observable {\n\n  constructor(sdpConstr, joiner = false) {\n\n    if (!sdpConstr) {\n\n      throw new Error('Manadatory spd constraints missing.');\n    }\n\n    const internalObservable = new Rx.Observable(subscriber => {\n      const dataChannelError = error => {\n\n        subscriber.error({\n          'type': 'error',\n          'cause': error\n        });\n      }\n      , dataChannelMessage = event => {\n\n        if (event &&\n          event.data) {\n\n          if ((typeof event.data === 'string' || String.prototype.isPrototypeOf(event.data)) &&\n            event.data.indexOf('_signaler') >= 0) {\n\n            switch (event.data) {\n              case '_signaler:got-stream?': {\n\n                subscriber.next({\n                  'type': 'add-stream'\n                });\n                break;\n              }\n              default: {\n\n                subscriber.error({\n                  'type': 'warn',\n                  'cause': 'Not interesting event atm'\n                });\n              }\n            }\n          } else {\n\n            subscriber.next({\n              'type': 'datachannel-message',\n              'payload': JSON.parse(event.data)\n            });\n          }\n        } else {\n\n          subscriber.error({\n            'type': 'error',\n            'cause': 'Event data not present'\n          });\n        }\n      }\n      , dataChannelOpen = () => {\n\n        subscriber.next({\n          'type': 'datachannel-opened'\n        });\n      }\n      , dataChannelClose = () => {\n\n        subscriber.next({\n          'type': 'datachannel-closed'\n        });\n      }\n      , negotiationNeeded = () => {\n\n        this[peerConnectionSym].createOffer()\n          .then(offer => {\n\n            subscriber.next({\n              'type': 'offer',\n              offer\n            });\n            return Promise.all([\n              this[peerConnectionSym].setLocalDescription(new RTCSessionDescription(offer)),\n              Promise.resolve(offer)\n            ]);\n          })\n          .then(resolved => subscriber.next({\n            'type': 'offer-set',\n            'offer': resolved[1]\n          }))\n          .catch(error => {\n\n            subscriber.error({\n              'type': 'error',\n              'cause': error\n            });\n          });\n      };\n\n      this[peerConnectionSym] = new RTCPeerConnection(rtcConfiguration, rtcOptions);\n      if (!joiner) {\n\n        this[dataChannelSym] = this[peerConnectionSym].createDataChannel('signaler-datachannel', rtcDataChannelOptions);\n        this[dataChannelSym].onerror = dataChannelError;\n        this[dataChannelSym].onmessage = dataChannelMessage;\n        this[dataChannelSym].onopen = dataChannelOpen;\n        this[dataChannelSym].onclose = dataChannelClose;\n      }\n\n      this[peerConnectionSym].onnegotiationneeded = negotiationNeeded;\n\n      this[peerConnectionSym].onicecandidate = event => {\n\n        if (event.candidate) {\n\n          this[iceCandidatesSym].push(event.candidate);\n        } else if (this[iceCandidatesSym] &&\n          this[iceCandidatesSym].length >= 0) {\n\n          subscriber.next({\n            'type': 'use-ice-candidates',\n            'candidates': this[iceCandidatesSym].splice(0, this[iceCandidatesSym].length)\n          });\n        }\n      };\n\n      this[peerConnectionSym].onaddstream = event => {\n\n        if (!event ||\n          !event.stream) {\n\n          return subscriber.error({\n            'type': 'warning',\n            'cause': 'No stream arrived'\n          });\n        }\n\n        subscriber.next({\n          'type': 'add-stream',\n          'stream': event.stream\n        });\n      };\n\n      this[peerConnectionSym].onremovestream = event => {\n\n        if (!event ||\n          !event.stream) {\n\n          return subscriber.error({\n            'type': 'warning',\n            'cause': 'No stream arrived'\n          });\n        }\n\n        subscriber.next({\n          'type': 'remove-stream',\n          'stream': event.stream\n        });\n      };\n\n      this[peerConnectionSym].oniceconnectionstatechange = event => {\n\n        if (!event ||\n          !event.target ||\n          !event.target.iceConnectionState) {\n\n          return subscriber.error({\n            'type': 'warning',\n            'cause': 'ice connection state changed without event value'\n          });\n        }\n\n        switch (event.target.iceConnectionState) {\n\n          case 'connected':\n          case 'completed': {\n\n            subscriber.next({\n              'type': 'ready',\n              'state': event.target.iceConnectionState\n            });\n            break;\n          }\n\n          default: {\n\n            subscriber.next({\n              'type': 'ice-connection-state',\n              'state': event.target.iceConnectionState\n            });\n          }\n        }\n      };\n\n      this[peerConnectionSym].onsignalingstatechange = event => {\n\n        if (!event ||\n          !event.target ||\n          !event.target.signalingState) {\n\n          return subscriber.error({\n            'type': 'error',\n            'cause': 'signaling state changed without event value'\n          });\n        }\n\n        switch (event.target.signalingState) {\n\n          default: {\n\n            subscriber.next({\n              'type': 'signaling-state',\n              'state': event.target.signalingState\n            });\n          }\n        }\n      };\n\n      this[peerConnectionSym].ondatachannel = event => {\n\n        if (!event ||\n          !event.channel) {\n\n          return subscriber.error({\n            'type': 'error',\n            'cause': 'channel in event is not present'\n          });\n        }\n\n        this[dataChannelSym] = event.channel;\n        event.channel.onerror = dataChannelError;\n        event.channel.onmessage = dataChannelMessage;\n        event.channel.onopen = dataChannelOpen;\n        event.channel.onclose = dataChannelClose;\n      };\n\n      this.setAnswer = answer => {\n\n        this[peerConnectionSym].setRemoteDescription(new RTCSessionDescription(answer))\n          .then(() => {\n\n            subscriber.next({\n              'type': 'answer-set',\n              answer\n            });\n          });\n      };\n\n      this.setOffer = offer => {\n\n        this[peerConnectionSym].setRemoteDescription(new RTCSessionDescription(offer))\n          .then(() => {\n\n            subscriber.next({\n              'type': 'offer-set',\n              offer\n            });\n            return this[peerConnectionSym].createAnswer(this.sdpConstr);\n          })\n          .then(answer => {\n\n            subscriber.next({\n              'type': 'answer',\n              answer\n            });\n            return Promise.all([\n              this[peerConnectionSym].setLocalDescription(new RTCSessionDescription(answer)),\n              Promise.resolve(answer)\n            ]);\n          })\n          .then(resolved => subscriber.next({\n            'type': 'answer-set',\n            'answer': resolved[1]\n          }))\n          .catch(error => {\n\n            subscriber.error({\n              'type': 'error',\n              'cause': error\n            });\n          });\n      };\n\n      return () => {\n\n        this[dataChannelSym].close();\n        this[peerConnectionSym].close();\n      };\n    }).share();\n\n    super(observer => {\n\n      const subscriptionToInternalObservable = internalObservable\n        .subscribe(observer);\n\n      return () => {\n\n        subscriptionToInternalObservable.unsubscribe();\n      };\n    });\n\n    this[iceCandidatesSym] = [];\n    this.sdpConstr = sdpConstr;\n  }\n\n  addIceCandidates(candidates) {\n\n    if (candidates) {\n\n      candidates.forEach(element => this[peerConnectionSym].addIceCandidate(new RTCIceCandidate(element)));\n    } else {\n\n      throw new Error('Invalid candidates');\n    }\n  }\n\n  get dataChannel() {\n\n    if (!this[dataChannelSym]) {\n\n      throw new Error('Datachannel is not created');\n    }\n\n    return this[dataChannelSym];\n  }\n}\n\nexport {SignalerPeerConnection};\n","/*global window,navigator*/\nimport Rx from 'rxjs/Rx';\nimport {Comunicator} from 'comunicator';\nimport {SignalerPeerConnection} from './p2p.js';\n\nconst comunicatorSym = Symbol('comunicator')\n  , myStreamSym = Symbol('my-stream')\n  , userMediaConstraintsSym = Symbol('user-media-constraint')\n  , sdpConstraintsSym = Symbol('sdp-constraints')\n  , initiatorsSym = Symbol('initiators')\n  , peersSym = Symbol('peers')\n  , subscriptionsSym = Symbol('subscriptions')\n  , unknownPeerValue = 'unknown-peer'\n  , getUserMediaConstraints = {\n    'audio': true,\n    'video': true\n  }\n  , sdpConstraints = {\n    'mandatory': {\n      'OfferToReceiveAudio': true,\n      'OfferToReceiveVideo': true\n    }\n  };\n\nclass Signaler extends Rx.Observable {\n  constructor(websocketUrl, getUserMediaConstr = getUserMediaConstraints, sdpConstr = sdpConstraints, debug = false) {\n\n    const internalObservable = new Rx.Observable(subscriber => {\n\n      this[comunicatorSym]\n        .filter(element => element.what &&\n          element.what.type === 'do-handshake')\n        .forEach(element => {\n\n          if (element.whoami &&\n            element.what.channel) {\n            const p2pConnection = new SignalerPeerConnection(sdpConstr)\n              , subscriptionsArray = [];\n\n            this[initiatorsSym].set(element.what.channel, element.who);\n            if (debug) {\n\n              subscriptionsArray.push(\n                p2pConnection.subscribe({\n                  'next': debugElement => console.info(debugElement),\n                  'error': err => console.error(err),\n                  'complete': () => console.info('DONE!')\n                })\n              );\n            }\n\n            subscriptionsArray.push(\n              p2pConnection\n                .filter(fromPeerConnection => fromPeerConnection.type === 'offer')\n                .subscribe({\n                  'next': fromPeerConnection => this[comunicatorSym].sendTo(element.whoami, {\n                    'channel': element.what.channel,\n                    'offer': fromPeerConnection.offer\n                  }),\n                  'error': err => console.error(err),\n                  'complete': () => console.info('DONE!')\n                })\n            );\n\n            subscriptionsArray.push(\n              p2pConnection\n                .filter(fromPeerConnection => fromPeerConnection.type === 'use-ice-candidates')\n                .subscribe({\n                  'next': fromPeerConnection => this[comunicatorSym].sendTo(element.whoami, {\n                    'channel': element.what.channel,\n                    'candidates': fromPeerConnection.candidates\n                  }),\n                  'error': err => console.error(err),\n                  'complete': () => console.info('DONE!')\n                })\n            );\n\n            subscriptionsArray.push(\n              p2pConnection\n                .filter(fromPeerConnection => fromPeerConnection.type === 'datachannel-message')\n                .subscribe({\n                  'next': fromPeerConnection => subscriber.next(fromPeerConnection),\n                  'error': err => console.error(err),\n                  'complete': () => console.info('DONE!')\n                })\n            );\n\n            if (!this[peersSym].has(`${element.what.channel}`)) {\n\n              this[peersSym].set(`${element.what.channel}`, new Map());\n            }\n            this[peersSym].get(`${element.what.channel}`).set(`${element.who}`, p2pConnection);\n\n            if (this[subscriptionsSym].has(`${element.what.channel}`)) {\n\n              this[subscriptionsSym].set(`${element.what.channel}`, this[subscriptionsSym].get(`${element.what.channel}`).concat(subscriptionsArray));\n            } else {\n\n              this[subscriptionsSym].set(`${element.what.channel}`, subscriptionsArray);\n            }\n          } else {\n\n            window.setTimeout(() => {\n\n              throw new Error('Missing sender and channel that are mandatory');\n            });\n          }\n        });\n\n      this[comunicatorSym]\n        .filter(element => element.what &&\n        element.what.offer)\n        .forEach(element => {\n\n          if (element.whoami &&\n            element.what.channel &&\n            element.what.offer) {\n            let p2pConnection;\n            const subscriptionsArray = [];\n\n            if (!this[peersSym].has(`${element.what.channel}`)) {\n\n              this[peersSym].set(`${element.what.channel}`, new Map());\n            }\n\n            if (this[peersSym].get(`${element.what.channel}`).has(`${element.who}`)) {\n\n              p2pConnection = this[peersSym].get(`${element.what.channel}`).get(`${element.who}`);\n            } else {\n              p2pConnection = new SignalerPeerConnection(sdpConstr, true);\n\n              this[initiatorsSym].set(element.what.channel, element.whoami);\n              this[peersSym].get(`${element.what.channel}`).set(`${element.who}`, p2pConnection);\n            }\n\n            if (debug) {\n\n              subscriptionsArray.push(\n                p2pConnection.subscribe({\n                  'next': debugElement => console.info(debugElement),\n                  'error': err => console.error(err),\n                  'complete': () => console.info('DONE!')\n                })\n              );\n            }\n\n            subscriptionsArray.push(\n              p2pConnection\n                .filter(fromPeerConnection => fromPeerConnection.type === 'answer')\n                .subscribe({\n                  'next': fromPeerConnection => this[comunicatorSym].sendTo(element.whoami, {\n                    'channel': element.what.channel,\n                    'answer': fromPeerConnection.answer\n                  }),\n                  'error': err => console.error(err),\n                  'complete': () => console.info('DONE!')\n                })\n            );\n\n            subscriptionsArray.push(\n              p2pConnection\n                .filter(fromPeerConnection => fromPeerConnection.type === 'use-ice-candidates')\n                .subscribe({\n                  'next': fromPeerConnection => this[comunicatorSym].sendTo(element.whoami, {\n                    'channel': element.what.channel,\n                    'candidates': fromPeerConnection.candidates\n                  }),\n                  'error': err => console.error(err),\n                  'complete': () => console.info('DONE!')\n                })\n            );\n\n            subscriptionsArray.push(\n              p2pConnection\n                .filter(fromPeerConnection => fromPeerConnection.type === 'datachannel-message')\n                .subscribe({\n                  'next': fromPeerConnection => subscriber.next(fromPeerConnection),\n                  'error': err => console.error(err),\n                  'complete': () => console.info('DONE!')\n                })\n            );\n            p2pConnection.setOffer(element.what.offer);\n\n            if (this[subscriptionsSym].has(`${element.what.channel}`)) {\n\n              this[subscriptionsSym].set(`${element.what.channel}`, this[subscriptionsSym].get(`${element.what.channel}`).concat(subscriptionsArray));\n            } else {\n\n              this[subscriptionsSym].set(`${element.what.channel}`, subscriptionsArray);\n            }\n          } else {\n\n            window.setTimeout(() => {\n\n              throw new Error('Missing sender, channel and the offer that are mandatory');\n            });\n          }\n        });\n\n      this[comunicatorSym]\n        .filter(element => element.what &&\n        element.what.answer)\n        .forEach(element => {\n\n          if (element.whoami &&\n            element.what.channel &&\n            element.what.answer) {\n\n            if (this[peersSym].has(`${element.what.channel}`) &&\n              this[peersSym].get(`${element.what.channel}`).has(`${element.who}`)) {\n              const p2pConnection = this[peersSym].get(`${element.what.channel}`).get(`${element.who}`);\n\n              p2pConnection.setAnswer(element.what.answer);\n            } else {\n\n              window.setTimeout(() => {\n\n                throw new Error('The peer connection must be already enstablished');\n              });\n            }\n          } else {\n\n            window.setTimeout(() => {\n\n              throw new Error('Missing sender, channel and the answer that are mandatory');\n            });\n          }\n        });\n\n      this[comunicatorSym]\n        .filter(element => element.what &&\n        element.what.candidates)\n        .forEach(element => {\n\n          if (this[peersSym].has(`${element.what.channel}`) &&\n              this[peersSym].get(`${element.what.channel}`).has(`${element.who}`)) {\n            const p2pConnection = this[peersSym].get(`${element.what.channel}`).get(`${element.who}`);\n\n            p2pConnection.addIceCandidates(element.what.candidates);\n          } else {\n\n            window.setTimeout(() => {\n\n              throw new Error('The peer connection must be already enstablished');\n            });\n          }\n        });\n\n      this[comunicatorSym]\n        .filter(element => element.what &&\n          element.what.type === 'master-quits' &&\n        element.whoami !== this[comunicatorSym].whoAmI)\n        .forEach(element => {\n\n          this.leaveChannel(element.what.channel, true);\n        });\n\n      this.getUserMedia = () => {\n\n        navigator.mediaDevices.getUserMedia(this.userMediaConstraints)\n          .then(localStream => {\n\n            if (!this[myStreamSym]) {\n\n              subscriber.next({\n                'type': 'my-stream',\n                'stream': localStream\n              });\n              this[myStreamSym] = localStream;\n            }\n\n            //TODO try to put the contextified audio\n            //audioContext.createMediaStreamSource(myStream);\n            //, contextifiedLocalStream = audioContext.createMediaStreamDestination();\n          })\n          .catch(error => {\n\n            throw new Error(error);\n          });\n      };\n    }).share();\n\n    super(observer => {\n\n      const subscriptionToInternalObservable = internalObservable\n        .subscribe(observer);\n\n      return () => {\n\n        subscriptionToInternalObservable.unsubscribe();\n      };\n    });\n\n    this[comunicatorSym] = new Comunicator(websocketUrl);\n    this[userMediaConstraintsSym] = getUserMediaConstr;\n    this[sdpConstraintsSym] = sdpConstr;\n    this[peersSym] = new Map();\n    this[initiatorsSym] = new Map();\n    this[subscriptionsSym] = new Map();\n  }\n\n  createChannel(channel) {\n\n    if (!channel) {\n\n      throw new Error('Missing mandatory <channel> parameter.');\n    }\n\n    this[comunicatorSym].sendTo(unknownPeerValue, {\n      'type': 'create-channel',\n      channel\n    }, true);\n  }\n\n  joinChannel(channel) {\n\n    if (!channel) {\n\n      throw new Error('Missing mandatory <channel> parameter.');\n    }\n\n    this[comunicatorSym].sendTo(unknownPeerValue, {\n      'type': 'join-channel',\n      channel\n    }, true);\n  }\n\n  streamOnChannel() {\n\n  }\n\n  sendTo(channel, who, what) {\n\n    if (this[peersSym].has(`${channel}`) &&\n    this[peersSym].get(`${channel}`).has(`${who}`)) {\n      const dataChannel = this[peersSym].get(`${channel}`).get(`${who}`).dataChannel;\n\n      dataChannel.send(JSON.stringify(what));\n    } else {\n\n      throw new Error(`User ${who} for channel ${channel} do not exist`);\n    }\n  }\n\n  broadcast(channel, what) {\n\n    if (this[peersSym].has(`${channel}`)) {\n      const channelMap = this[peersSym].get(`${channel}`)\n        , entriesInChannelMap = channelMap.values();\n\n      for (const aUserInChannel of entriesInChannelMap) {\n        const dataChannel = aUserInChannel.dataChannel;\n\n        dataChannel.send(JSON.stringify(what));\n      }\n    } else {\n\n      throw new Error(`Channel ${channel} doesn't exist`);\n    }\n  }\n\n  approve() {\n\n  }\n\n  unApprove() {\n\n  }\n\n  leaveChannel(channel, keepMyStream) {\n\n    if (this[peersSym].has(`${channel}`)) {\n      const subscriptionsMap = this[subscriptionsSym].get(`${channel}`);\n\n      for (const aSubscription of subscriptionsMap) {\n\n        aSubscription.unsubscribe();\n      }\n\n      if (!keepMyStream &&\n        this[myStreamSym]) {\n\n        this[myStreamSym].stop();\n        this[myStreamSym] = undefined;\n      }\n      this[initiatorsSym].delete(channel);\n      this[peersSym].delete(channel);\n      this[subscriptionsSym].delete(channel);\n      //delete approvedUsers[channel]; TODO approved users\n      this[comunicatorSym].sendTo(unknownPeerValue, {\n        'type': 'leave-channel',\n        channel\n      }, true);\n    } else {\n\n      throw new Error(`Channel ${channel} doesn't exist`);\n    }\n  }\n\n  userIsPresent(whoami, token) {\n\n    return this[comunicatorSym].userIsPresent(whoami, token);\n  }\n\n  get userMediaConstraints() {\n\n    return this[userMediaConstraintsSym];\n  }\n\n  get sdpConstraints() {\n\n    return this[sdpConstraintsSym];\n  }\n\n  get stream() {\n\n    if (!this[myStreamSym]) {\n\n      throw new Error('Stream is not present. You have to ask this to the user');\n    }\n\n    return this[myStreamSym];\n  }\n\n  get peers() {\n\n    return this[peersSym];\n  }\n\n  get initiators() {\n\n    return this[initiatorsSym];\n  }\n}\n\nexport {Signaler};\n"],"names":["rtcConfiguration","rtcOptions","rtcDataChannelOptions","iceCandidatesSym","Symbol","peerConnectionSym","dataChannelSym","SignalerPeerConnection","sdpConstr","joiner","Error","internalObservable","Rx","Observable","dataChannelError","error","dataChannelMessage","event","data","String","prototype","isPrototypeOf","indexOf","next","JSON","parse","dataChannelOpen","dataChannelClose","negotiationNeeded","createOffer","then","Promise","all","_this","setLocalDescription","RTCSessionDescription","offer","resolve","subscriber","resolved","RTCPeerConnection","createDataChannel","onerror","onmessage","onopen","onclose","onnegotiationneeded","onicecandidate","candidate","push","length","splice","onaddstream","stream","onremovestream","oniceconnectionstatechange","target","iceConnectionState","onsignalingstatechange","signalingState","ondatachannel","channel","setAnswer","setRemoteDescription","answer","setOffer","createAnswer","close","share","subscriptionToInternalObservable","subscribe","observer","unsubscribe","candidates","forEach","_this2","addIceCandidate","RTCIceCandidate","element","this","comunicatorSym","myStreamSym","userMediaConstraintsSym","sdpConstraintsSym","initiatorsSym","peersSym","subscriptionsSym","unknownPeerValue","getUserMediaConstraints","sdpConstraints","Signaler","websocketUrl","getUserMediaConstr","debug","filter","what","type","whoami","p2pConnection","subscriptionsArray","set","who","console","info","debugElement","err","fromPeerConnection","sendTo","has","Map","get","concat","setTimeout","addIceCandidates","whoAmI","leaveChannel","getUserMedia","mediaDevices","userMediaConstraints","localStream","Comunicator","dataChannel","send","stringify","channelMap","entriesInChannelMap","values","aUserInChannel","keepMyStream","subscriptionsMap","aSubscription","stop","undefined","token","userIsPresent"],"mappings":"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"}