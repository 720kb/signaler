{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["/*global module,process,require*/\n\nconst ObservableState = require('./observable-state');\n\nmodule.exports = comunicator => {\n\n  if (!comunicator) {\n\n    throw new Error('Comunicator object missing');\n  }\n  const signalerState = new ObservableState();\n\n  signalerState\n    .filter(element => element.type === 'added')\n    .map(element => element.value)\n    .filter(element => element.role === 'master')\n    .forEach(element => {\n      if (element.channel &&\n        element.user) {\n\n        const channel = signalerState.getChannelInState(element.channel)\n          , channelElements = Object.keys(channel);\n\n        channelElements\n          .forEach(userIdentification => {\n            const userInChannelDescription = channel[userIdentification];\n\n            if (userInChannelDescription.role === 'slave') {\n\n              comunicator.sendTo(userInChannelDescription.user, element.user, {\n                'type': 'do-handshake',\n                'channel': userInChannelDescription.channel\n              });\n            }\n          });\n      } else {\n\n        process.nextTick(() => {\n\n          throw new Error('Missing mandatory fields channel and user');\n        });\n      }\n    });\n\n  signalerState\n    .filter(element => element.type === 'added')\n    .map(element => element.value)\n    .filter(element => element.role === 'slave')\n    .forEach(element => {\n      if (element.channel &&\n        element.user) {\n\n        const channel = signalerState.getChannelInState(element.channel)\n          , channelElements = Object.keys(channel);\n\n        channelElements\n          .forEach(userIdentification => {\n            const userInChannelDescription = channel[userIdentification];\n\n            if (userInChannelDescription.role === 'master') {\n\n              comunicator.sendTo(element.user, userInChannelDescription.user, {\n                'type': 'do-handshake',\n                'channel': userInChannelDescription.channel\n              });\n            }\n          });\n      } else {\n\n        process.nextTick(() => {\n\n          throw new Error('Missing mandatory fields channel and user');\n        });\n      }\n    });\n\n  signalerState\n    .filter(element => element.type === 'quit')\n    .forEach(element => {\n\n      comunicator.broadcast(element.value, {\n        'type': 'i-quit',\n        'channel': element.channel\n      });\n    });\n\n  signalerState\n    .filter(element => element.type === 'master-quit')\n    .forEach(element => {\n\n      comunicator.broadcast(element.value, {\n        'type': 'master-quits',\n        'channel': element.channel\n      });\n    });\n\n  comunicator\n    .filter(element => element.type === 'message-arrived' &&\n      element.what &&\n      element.what.type === 'create-channel')\n    .map(element => ({\n      'channel': element.what.channel,\n      'whoami': element.whoami\n    }))\n    .forEach(element => {\n      if (element.channel) {\n        const theChannel = element.channel\n          , theUser = element.whoami;\n\n        if (!signalerState.containsInState(theChannel)) {\n\n          signalerState.addChannelInState(theChannel);\n        } else if (signalerState.getChannelInState(theChannel).master &&\n          signalerState.getChannelInState(theChannel).master.user !== theUser) {\n\n          process.nextTick(() => {\n\n            throw new Error('There is already a master user for this channel');\n          });\n        }\n\n        signalerState.getChannelInState(theChannel).master = {\n          'user': theUser,\n          'role': 'master',\n          'channel': theChannel\n        };\n      } else {\n\n        throw new Error('Missing mandatory <channel> value');\n      }\n    });\n\n  comunicator\n    .filter(element => element.type === 'message-arrived' &&\n      element.what &&\n      element.what.type === 'join-channel')\n    .map(element => ({\n      'channel': element.what.channel,\n      'whoami': element.whoami\n    }))\n    .forEach(element => {\n      if (element.channel) {\n        const theChannel = element.channel\n          , theUser = element.whoami;\n\n        if (!signalerState.containsInState(theChannel)) {\n\n          signalerState.addChannelInState(theChannel);\n        } else if (signalerState.getChannelInState(theChannel).master &&\n          signalerState.getChannelInState(theChannel).master.user === theUser) {\n\n          process.nextTick(() => {\n\n            throw new Error(`The user ${theUser} can be either master or slave`);\n          });\n        }\n\n        signalerState.getChannelInState(theChannel)[theUser] = {\n          'user': theUser,\n          'role': 'slave',\n          'channel': theChannel\n        };\n      } else {\n\n        throw new Error('Missing mandatory <channel> value');\n      }\n    });\n\n  comunicator\n    .filter(element => element.type === 'message-arrived' &&\n      element.what &&\n      element.what.type === 'leave-channel')\n    .forEach(element => {\n      const theChannel = signalerState.getChannelInState(element.what.channel)\n        , theChannelKeys = Object.keys(theChannel)\n        , theChannelKeysLength = theChannelKeys.length;\n\n      for (let theChannelKeysIndex = 0; theChannelKeysIndex < theChannelKeysLength; theChannelKeysIndex += 1) {\n        const aChannelUser = theChannelKeys[theChannelKeysIndex];\n\n        if (theChannel[aChannelUser] &&\n          theChannel[aChannelUser].user === element.whoami) {\n\n          delete theChannel[aChannelUser];\n        }\n      }\n    });\n\n  comunicator\n    .filter(element => element.type === 'user-leave')\n    .forEach(element => {\n\n      console.info(element, signalerState);//TODO: fix this!\n      /*for (const aChannel of signalerState.channels) {\n\n        if (aChannel &&\n          aChannel[0] &&\n          aChannel[1]) {\n          const aChannelName = aChannel[0]\n            , usersInChannel = aChannel[1]\n            , usersInChannelLength = usersInChannel.length;\n\n          for (let usersInChannelIndex = usersInChannelLength - 1; usersInChannelIndex >= 0; usersInChannelIndex -= 1) {\n            let aUserInChannel = usersInChannel[usersInChannelIndex];\n\n            if (aUserInChannel &&\n              aUserInChannel.user === element.whoami) {\n\n              usersInChannel.splice(usersInChannelIndex, 1);\n            }\n          }\n        }\n      }*/\n    });\n\n  /*comunicator\n    .filter(element => element.type === 'message-arrived' &&\n      element.what &&\n      element.what.type === 'approve')\n    .forEach(element => {\n      const theChannel = signalerState.channels[element.channel];\n\n      theChannel.forEach(anElement => {\n\n        if (anElement &&\n          anElement.user === element.who &&\n          !anElement.approved) {\n\n          anElement.approved = true;\n        } else if (anElement.role !== 'master') {\n\n          comunicator.sendTo(element.who, anElement.user, {\n            'type': 'approved',\n            'channel': anElement.channel\n          });\n        }\n      });\n    });\n\n  comunicator\n    .filter(element => element.type === 'message-arrived' &&\n      element.what &&\n      element.what.type === 'un-approve')\n    .forEach(element => {\n      const theChannel = signalerState.channels[element.channel];\n\n      theChannel.forEach(anElement => {\n\n        if (anElement &&\n          anElement.user === element.who &&\n          anElement.approved) {\n          const usersInChannelExceptApproved = theChannel.filter(anElementToFilter => {\n\n            if (anElementToFilter.user !== element.who &&\n              anElementToFilter.role !== 'master') {\n\n              return true;\n            }\n          }).map(anElementToMap => {\n\n            return anElementToMap.user;\n          });\n\n          delete anElement.approved;\n          comunicator.sendTo(element.whoami, element.who, {\n            'type': 'you-are-un-approved',\n            'channel': anElement.channel,\n            'users': usersInChannelExceptApproved\n          });\n        } else if (anElement.role === 'slave') {\n\n          comunicator.sendTo(element.who, anElement.user, {\n            'type': 'un-approved',\n            'channel': anElement.channel\n          });\n        }\n      });\n    });*/\n};\n"],"sourceRoot":"/source/"}